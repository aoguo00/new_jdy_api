# 缓存恢复时穿梭框模块过滤修复说明

## 问题描述

当从缓存恢复PLC配置时，左侧穿梭框（可用模块列表）没有正确过滤已配置的模块，导致：
- 已经配置到右侧的模块仍然出现在左侧
- 用户可能重复添加相同的模块
- 界面显示不一致

**特别是对于同一型号的多个模块实例**（如数量为4的LK610），只有部分实例被正确排除，剩余实例仍显示在左侧。

## 根本原因

问题出现在 **同一型号多个实例的 `unique_id` 管理**：

1. **设备数据处理**：当场站设备数据中某个模块数量>1时，`get_current_devices` 方法会为每个数量创建一个实例
2. **unique_id 生成**：每个实例在 `_load_all_available_modules_with_unique_ids` 中被赋予不同的 `unique_id`
3. **缓存恢复问题**：缓存恢复时，只按型号查找第一个匹配的模块实例，导致同一型号的其他实例未被标记为已配置
4. **过滤失效**：`_rebuild_current_modules_pool` 只能排除部分已配置的实例

### 示例场景
- 场站数据：LK610 数量=4，生成4个实例（unique_id: mod_1, mod_2, mod_3, mod_4）
- 用户配置：将4个LK610实例都配置到机架
- 缓存恢复：只有第一个实例被标记为已配置，其余3个仍显示在左侧

## 修复方案

### 深度修复：基于模块需求统计的智能分配

在 `_restore_config_from_cache` 方法中实现：

#### 1. 统计模块需求
```python
# 统计每个型号需要配置的数量
model_count_needed = {}
for (rack_id, slot_id), model_name in self.current_config.items():
    model_count_needed[model_name.upper()] = model_count_needed.get(model_name.upper(), 0) + 1
```

#### 2. 预留模块实例
```python
# 为每个型号预留对应数量的模块实例
reserved_modules = {}  # {model_name: [module_instances]}
for model_name_upper, needed_count in model_count_needed.items():
    available_instances = [
        m for m in self.all_available_modules 
        if m.get('model', '').upper() == model_name_upper
    ]
    if len(available_instances) >= needed_count:
        reserved_modules[model_name_upper] = available_instances[:needed_count]
```

#### 3. 按需分配实例
```python
# 分配模块实例到具体的配置位置
model_instance_counters = {model: 0 for model in model_count_needed.keys()}

for (rack_id, slot_id), model_name in self.current_config.items():
    model_name_upper = model_name.upper()
    instance_counter = model_instance_counters[model_name_upper]
    
    if model_name_upper in reserved_modules and instance_counter < len(reserved_modules[model_name_upper]):
        # 使用预留的模块实例
        found_module = reserved_modules[model_name_upper][instance_counter].copy()
        self.configured_modules[(rack_id, slot_id)] = found_module
        model_instance_counters[model_name_upper] += 1
```

## 修复效果

### 修复前
- **LK610 数量4个**：配置4个到右侧，但左侧仍显示3个LK610
- **LK411 数量2个**：配置2个到右侧，但左侧可能仍显示1个LK411
- 用户可能重复添加模块

### 修复后
- **精确计算**：统计每个型号的实际配置需求
- **智能预留**：为每个型号预留正确数量的实例
- **完全匹配**：所有已配置的实例都被正确排除
- **界面清洁**：左侧只显示真正可用的模块

## 技术亮点

### 1. 需求导向的分配策略
- 不再盲目匹配第一个找到的实例
- 基于实际配置需求进行智能分配
- 确保每个配置位置都有对应的唯一实例

### 2. 实例计数器机制
```python
model_instance_counters = {model: 0 for model in model_count_needed.keys()}
```
- 为每个型号维护独立的实例计数器
- 确保同一型号的不同实例按顺序分配

### 3. 预留机制
- 先统计需求，再预留实例
- 避免实例分配冲突
- 提供详细的日志记录

## 测试场景

### 1. 同型号多实例场景
- **LK610 数量=4**：配置全部4个 → 左侧应完全清空LK610
- **LK411 数量=2**：配置全部2个 → 左侧应完全清空LK411

### 2. 部分配置场景
- **LK610 数量=4**：只配置2个 → 左侧应显示剩余2个LK610
- **混合配置**：不同型号的部分配置

### 3. 缓存恢复验证
- 配置后切换场站 → 再切换回来 → 验证左侧穿梭框正确性

## 相关文件

- `ui/dialogs/plc_config_dialog.py` - 主要修复文件（`_restore_config_from_cache` 方法）
- `ui/main_window.py` - 模块实例生成逻辑（`get_current_devices` 方法）
- `core/io_table/get_data.py` - 缓存机制实现

## 技术要点

1. **需求统计优先**：先分析配置需求，再分配实例
2. **实例唯一性**：确保每个配置位置对应唯一的模块实例
3. **智能预留**：基于需求预留模块实例，避免冲突
4. **详细日志**：提供完整的分配过程追踪
5. **容错处理**：当实例不足时的降级处理机制

这次修复彻底解决了同一型号多个实例的缓存恢复问题，确保穿梭框显示的准确性和用户体验的一致性 